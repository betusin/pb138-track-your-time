import { AxiosError, AxiosRequestConfig, AxiosResponse } from "axios";
import toast from "react-hot-toast";
import { unauthorizedText, unexpectedErrorText } from "../strings";
import { useRecoilValue } from "recoil";
import { accessTokenAtom } from "../state/atom";
import { SWRResponse } from "swr";
import { useEffect } from "react";

/**
 * A custom hook to perform an SWR call, where the Bearer
 * token is automatically included in the request.
 * @param callGenerator Creates the API call with the provided options
 */
export function useApiSwrCall<
  T extends SWRResponse<AxiosResponse, AxiosError<void>>
>(callGenerator: (options: SwrCallOptions) => T): T {
  const token = useRecoilValue(accessTokenAtom);
  const options = {
    axios: {
      headers: {
        Authorization: "Bearer " + token,
      },
    },
  };
  const result = callGenerator(options);
  const { error, data } = result;
  useEffect(() => {
    if (error?.isAxiosError) {
      toast.error(unexpectedErrorText);
    } else if (data?.status) {
      if (!isSuccessfulStatus(data.status)) {
        onUnhandledNetworkCode(data.status);
      }
    }
  }, [error, data]);
  return result;
}

/**
 * A custom hook for app API calls. Includes automatic token
 * inclusion and error handling (which can be overridden).
 */
export function useApiCall(): ApiCaller {
  const token = useRecoilValue(accessTokenAtom);
  return <I, O>(
    a: ApiCall<I, O>,
    b: I,
    c: (x: O) => void,
    d?: (x: number) => boolean,
    axiosOptions?: AxiosRequestConfig
  ) => {
    return doNetworkCall(a, b, c, d, token, axiosOptions);
  };
}

/**
 * Options provided to the SWR api call generator.
 */
export interface SwrCallOptions {
  axios?: AxiosRequestConfig;
}

/**
 * An API call autogenerated by Orval.
 */
export type ApiCall<I, A> = (
  input: I,
  options?: AxiosRequestConfig
) => Promise<AxiosResponse<A>>;

/**
 * The function to perform an API call
 * returned by useApiCall.
 */
export type ApiCaller = <I, O>(
  apiCall: ApiCall<I, O>,
  requestBody: I,
  onSuccess: (result: O) => void,
  onBadResponse?: (code: number) => boolean,
  axiosOptions?: AxiosRequestConfig
) => void;

function doNetworkCall<I, A>(
  func: (input: I, options?: AxiosRequestConfig) => Promise<AxiosResponse<A>>,
  inputData: I,
  onSuccess: (result: A) => void,
  onBadResponse?: (code: number) => boolean,
  token?: string,
  axiosOptions?: AxiosRequestConfig
) {
  if (token) {
    const tokenOptions = {
      headers: {
        Authorization: "Bearer " + token,
      },
    };
    axiosOptions = { ...tokenOptions, ...axiosOptions };
  }
  const call = func(inputData, axiosOptions);
  call
    .then((result) => onNetworkCallResult(result, onSuccess, onBadResponse))
    .catch(onUnhandledNetworkException);
}

function onNetworkCallResult<A>(
  result: AxiosResponse<A>,
  onSuccess: (result: A) => void,
  onBadResponse: ((code: number) => boolean) | undefined
) {
  const status = result.status;
  if (isSuccessfulStatus(status)) {
    // Everything is fine
    onSuccess(result.data);
    return;
  }
  if (onBadResponse !== undefined && onBadResponse(status)) {
    // Error, but it was handled
    return;
  }
  // Error, not handled
  console.error(result);
  onUnhandledNetworkCode(status);
}

function onUnhandledNetworkCode(code: number) {
  switch (code) {
    case 401:
      toast.error(unauthorizedText);
      break;
    default:
      toast.error(unexpectedErrorText);
      break;
  }
}

function onUnhandledNetworkException(e: Error) {
  toast.error(unexpectedErrorText);
  console.error(e);
}

function isSuccessfulStatus(status: number) {
  return status == 200 || status == 201;
}
